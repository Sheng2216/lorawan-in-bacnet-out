# Standalone LoraWAN-in-BACnet-out Gateway

[TOC]

## 1. Introduction

This guide explains how the Standalone LoraWAN-in-BACnet-out Gateway works. We will use MQTT to subscribe uplink messages from TTN stack. Once the messages from the registered devices arrive to the LNS, they are being published as MQTT messages so we can process them, and send the messages out via BACnet IP.

### 1.1. Docker compose

We have 4 services defined in the [docker compose](./docker-compose.yml) file:

- `udp-packet-forwarder` interacts with the LoRa chip to receive and transfer LoRa packets
- `stack` is a TTN stack service which depends on `redis` and `postgres` service. This service enables connectivity, management, and monitoring of devices, gateways and end-user applications
- `redis` is the main data store for the Network Server, Application Server and Join Server, and it is also used by Identity Server and event system.
- `postgres` is another databased used by `stack`

### 1.2. Run services

The default RAKPiOS user name is **rak**, and the password is **rakpios**. At first login, you will be forced to change the default password. For example, if you log in via SSH for the first time, you will have to set a new one by entering the default one and a new one after.

After you loged in, enter the demo directory. You will find a executable script called`start.sh` . The included `start.sh` script takes care of tweaking the `dcoker-compose.yml` file to change the IP of the host and bring up all the service.

```bash
$ ./start.sh
Server Host is configured to:  10.2.13.254
Configuring docker-compose.yml file
Getting container images and services ready...
[+] Running 9/9
 ⠿ Network lorawan-in-mqtt-out_bridge       Created                              
 ⠿ Volume "lorawan-in-mqtt-out_redis"       Created                              
 ⠿ Volume "lorawan-in-mqtt-out_stack-blob"  Created                              
 ⠿ Volume "lorawan-in-mqtt-out_stack-data"  Created                              
 ⠿ Volume "lorawan-in-mqtt-out_postgres"    Created                              
 ⠿ Container redis                          Started                              
 ⠿ Container postgres                       Started                              
 ⠿ Container udp-packet-forwarder           Started                              
 ⠿ Container stack                          Started                              

---------------------------------------------------------------------
Gateway EUI  : e45f01FFFE51b75d
Stack URL    : https://10.2.13.254/       (admin/changeme)
The next step is to run ./BACnet-out.py
---------------------------------------------------------------------
```

After running it wait <mark>a few seconds</mark> for the Stack web UI to become alive and click on the provided link to access the web UI. The default User ID and Password is `admin` and `changeme`.

![image20220617153554724](assets/image-20220617153554724.png)

After you login, you need to create your a gateway first using the **GATEWAY_EUI** provided by the `start.sh` script, see the `2.1 Create Gateway` section below.

## 2. Preparation

### 2.1 Create gateway

You need to add your gateway to TTS first. Go to the **Gateway** configuration page, enter the general ID, Gateway EUI, Gateway server address, and also the frequency plan. If you use the default docker compose file, your gateway EUI can be acquired by running the following command in your host:

```
docker exec -it udp-packet-forwarder ./get_eui.sh
```

or you can copy it from the the configuration information generated by the `./start.sh `script (as shown below). The gateway server address is the one you defined when you run the `./start.sh` script. And make sure you choose the right frequency plan.

![image20220623091446030](/assets/snipaste_2022-11-21_18-36-48.png)

![image20220623091446030](/assets/image-20220623091446030.png)

after the gateway is created in TTS, you should be able to see the gateway is online in the gateway detail page:

![gateway is online](/assets/gateway-online.png)

### 2.2 Create application

Now, as we mentioned above, we need to create an application in TTS.

![image20220617155857075](/assets/image-20220617155857075.png)

![image20220617155946127](/assets/image-20220617155946127.png)

Select `Write downlink application traffic` and `Read application traffic (uplink and downlink)`at least. The two rights is needed by MQTT.

![image20220617160035024](/assets/image-20220617160035024.png)

Copy the API key, we will use it on NodeRED flow. Please note that you must copy the key and store it somewhere safe. If you forget to save it, you won't be able to see it again, unless you create a new API keys and copy it.

![image20220617160317654](/assets/image-20220617160317654.png)

### 2.3 Prepare end device

Now, the TTS side's configuration is about to finish, we need to add end-devices to the application so that we can start to receive uplink data sent by the end-devices on the gateway. But even before that, we need prepare the end device. The end device we used is a WisBlock kit with the RAK1901 sensor that reports temperature and humidity. You can find more details in RAKwireless's [official documentation](https://docs.rakwireless.com/Product-Categories/WisBlock/RAK1901/Quickstart/#software-configuration-and-example). The Arduino code [rak1901.ino](./rak1901/rak1901.ino) is provided, you can copy paste the code, and then upload to the board. Make sure to change the device EUI, the App EUI, and the App key.

![Arduino code](/assets/arduino-code.png)

Now we need to go back to the TTS, under the application page, add your first end-device:

![add enddevice](/assets/add-end-device.png)

switch to manually mode, and then enter the following higlighted section, make sure the DevEUI, AppEUI, AppKey match what you defined in the Arduino code:

![register enddevice](/assets/register-end-device.png)

After the end-device is registered, you should be able to see the end-device is online, and also the uplink data sent from the end-device:

![enddevice's live data](/assets/end-device-live-data.png?msec=1669027528502)

to make use of the CayenneLPP, you need to go to the end-device's page, and then in the **Payload formatters** page, switch the default ulplink formatter type to CayenneLPP:

![switch to cayenneLPP](/assets/cayenneLPP.png?msec=1669027528483)

now you should be able to see the converted live-data:

![converted live data](/assets/live-data.png?msec=1669027528488)

## 3. Create a BACnet application

We create a python demo script that can read the sensor data from MQTT broker and then send it out via BACnet. To do this, you only need to run the following command in the demo directory.

```
rak@rakpios:lorawan-in-bacnet-out $ ./BACnet-out.py 
Connected to MQTT Broker!
A sample BACnet application is created...
It will read temperature inputs from LoRaWAN nodes via MQTT, and then send it out via BACnet IP...
25.5
25.4
26.2
```

## 4. License

This project is licensed under MIT license.
